<h2>Gamma校正</h2>

下面这张图中：

![image](https://github.com/yu-cao/OpenGL-Learning/blob/master/5.2Gamma%20Correction/Reference/gamma_correction_brightness.png)

第一行是人眼所感知到的正常的灰阶，亮度要增加一倍（比如从0.3到0.6）你才会感觉比原来变亮了一倍（也就是说人眼感知到的亮度的变化并非线性均匀分布的）

当我们谈论光的物理亮度，比如光源发射光子的数量的时候，底部（第二行）的灰阶显示出的才是物理世界真实的亮度。如底部的灰阶显示，亮度加倍时返回的也是真实的物理亮度

但是由于这与我们的眼睛感知亮度不完全一致（人眼对暗的颜色变化更敏感），所以它看起来有差异。

因为人眼看到颜色的亮度更倾向于顶部的灰阶，显示器使用的也是一种指数关系（电压的2.2次幂），所以物理亮度通过监视器能够被映射到顶部的非线性亮度；因此看起来效果不错（CRT亮度是是电压的2.2次幂而人眼相当于2次幂，因此CRT这个缺陷正好能满足人的需要）。

但当渲染图像时，会产生一个问题：我们在应用中配置的亮度和颜色是基于监视器所看到的，这样所有的配置实际上是非线性的亮度/颜色配置。

![image](https://github.com/yu-cao/OpenGL-Learning/blob/master/5.2Gamma%20Correction/Reference/gamma_correction_gamma_curves.png)

点线代表线性颜色/亮度值（译注：这表示的是理想状态，Gamma为1），实线代表监视器显示的颜色。如果我们把一个点线线性的颜色翻一倍，结果就是这个值的两倍。比如，光的颜色向量L¯=(0.5,0.0,0.0)代表的是暗红色。如果我们在线性空间中把它翻倍，就会变成(1.0,0.0,0.0)，就像你在图中看到的那样。然而，由于我们定义的颜色仍然需要输出的监视器上，监视器上显示的实际颜色就会是(0.218,0.0,0.0)。在这儿问题就出现了：当我们将理想中直线上的那个暗红色翻一倍时，在监视器上实际上亮度翻了4.5倍以上！**（监视器所显示出来的图像和线性图像的最小亮度是相同的，它们最大的亮度也是相同的；只是中间亮度部分会被压暗）**

假设我们所有的工作都是在线性空间中进行的（Gamma为1），但最终还是要把所有的颜色输出到监视器上，所以我们配置的所有颜色和光照变量从物理角度来看都是不正确的。出于这个原因，我们通常将光照值设置得比本来更亮一些（由于监视器会将其亮度显示的更暗一些），如果不是这样，在线性空间里计算出来的光照就会不正确。

因为所有中间亮度都是线性空间计算出来的（计算的时候假设Gamma为1）屏幕显示以后，实际上都会不正确。当使用更高级的光照算法时，这个问题会变得越来越明显。

<hr>

这里引入**Gamma校正：在最终的颜色输出上应用监视器Gamma的倒数。**

前面的Gamma曲线图，有一个短划线的曲线，它是监视器Gamma曲线的翻转曲线。我们在颜色显示到监视器的时候把每个颜色输出都加上这个翻转的Gamma曲线，这样应用了监视器Gamma以后最终的颜色将会变为线性的。我们所得到的中间色调就会更亮，所以虽然监视器使它们变暗，但是我们又将其平衡回来了。

暗红色(0.5,0.0,0.0)。在将颜色显示到监视器之前，我们先对颜色应用Gamma校正曲线。线性的颜色显示在监视器上相当于降低了2.2次幂的亮度，所以倒数就是1/2.2次幂。Gamma校正后的暗红色就会成为(0.5,0.0,0.0)^(1/2.2) = (0.5,0.0,0.0)^0.45 = (0.73,0.0,0.0)。校正后的颜色接着被发送给监视器，最终显示出来的颜色是(0.73,0.0,0.0)^2.2 = (0.5,0.0,0.0)。你会发现使用了Gamma校正，监视器最终会显示出我们在应用中设置的那种线性的颜色。

<h3>应用Gamma校正</h3>

有两种在场景中应用gamma校正的方式：

+ 使用OpenGL内建的sRGB帧缓冲：开启`GL_FRAMEBUFFER_SRGB`，可以告诉OpenGL每个后续的绘制命令里，在颜色储存到颜色缓冲之前先校正sRGB颜色。开启后，每次像素着色器运行后续帧缓冲，OpenGL将自动执行gamma校正，包括默认帧缓冲。

  ```cpp
  glEnable(GL_FRAMEBUFFER_SRGB);
  ```
  
+ 自己在片元着色器中进行gamma校正：在每个相关片元着色器运行的最后应用gamma校正，所以在发送到帧缓冲前，颜色就被校正了。

```glsl
void main()
{
    // do super fancy lighting 
    [...]
    // apply gamma correction
    float gamma = 2.2;
    fragColor.rgb = pow(fragColor.rgb, vec3(1.0/gamma));
}
```

为了保持一致，必须在片元着色器里加上这个gamma校正，所以如果你有很多片元着色器，它们可能分别用于不同物体，那么你就必须在每个着色器里都加上gamma校正。一个更简单的方案是在你的渲染循环中引入后处理阶段，在后处理四边形上应用gamma校正，这样只要做一次就好了。

<hr>

<h3>sRGB纹理</h3>

因为监视器总是在sRGB空间中显示应用了gamma的颜色，无论什么时候当你在计算机上绘制、编辑或者画出一个图片的时候，你所选的颜色都是根据你在监视器上看到的那种。这实际意味着所有你创建或编辑的图片并不是在线性空间，而是在sRGB空间中(Gamma ≈ 2.2)

结果就是纹理编辑者，所创建的所有纹理都是在sRGB空间中的纹理，所以如果我们在渲染应用中使用这些纹理，我们必须考虑到这点。在我们应用gamma校正之前，这不是个问题，因为纹理在sRGB空间创建和展示，同样我们还是在sRGB空间中使用，从而不必gamma校正纹理显示也没问题。然而，现在我们是把所有东西都放在线性空间中展示的，纹理颜色就会变坏（发生两次Gamma校正，纹理显著变亮）

![image](https://github.com/yu-cao/OpenGL-Learning/blob/master/5.2Gamma%20Correction/Reference/gamma_correction_srgbtextures.png)

一种解决方法是：要求美术做出来的东西是在线性空间中进行的（不太可能）另一种方法是重校：把这些sRGB纹理在进行任何颜色值的计算前变回线性空间。

```glsl
float gamma = 2.2;
vec3 diffuseColor = pow(texture(diffuse, texCoords).rgb, vec3(gamma));
```

OpenGL给我们提供了另一个方案来解决我们的麻烦，这就是`GL_SRGB`和`GL_SRGB_ALPHA`内部纹理格式。

如果我们在OpenGL中创建了一个纹理，把它指定为以上两种sRGB纹理格式其中之一，OpenGL将自动把颜色校正到线性空间中，这样我们所使用的所有颜色值都是在线性空间中的了。我们可以这样把一个纹理指定为一个sRGB纹理：

```cpp
glTexImage2D(GL_TEXTURE_2D, 0, GL_SRGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, image);
```

如果你还打算在你的纹理中引入alpha元素，必须将纹理的内部格式指定为`GL_SRGB_ALPHA`。

<hr>

<h3>光照衰减</h3>

真实的物理世界中，光照的衰减和光源的距离的平方成反比。

```glsl
float attenuation = 1.0 / (distance * distance);
```

然而，当我们使用这个衰减公式的时候，衰减效果总是过于强烈，光只能照亮一小圈，看起来并不真实。而使用下面这个更加真实

```glsl
float attenuation = 1.0 / distance;
```

原因是，光的衰减方程改变了亮度值，而且屏幕上显示出来的也不是线性空间，在监视器上效果最好的衰减方程，并不是符合物理的。如果我们使用这个方程，而且不进行gamma校正，显示在监视器上的衰减方程实际上将变成(1.0/distance^2)^2.2 。若不进行gamma校正，将产生更强烈的衰减。这也解释了为什么双曲线不用gamma校正时看起来更真实，因为它实际变成了(1.0/distance)^2.2 = 1.0/distance^2.2 。这和物理公式是很相似的。

![image](https://github.com/yu-cao/OpenGL-Learning/blob/master/5.2Gamma%20Correction/Reference/gamma_correction_attenuation.png)