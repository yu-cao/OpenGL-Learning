<h2>光照模型</h2>
其中一个模型被称为冯氏光照模型(Phong Lighting Model)。冯氏光照模型的主要结构由3个分量组成：环境(Ambient)、漫反射(Diffuse)和镜面(Specular)光照。

![image](https://github.com/yu-cao/OpenGL-Learning/blob/master/2.2Basic%20Lighting/Reference/basic_lighting_phong.png)

+ 环境光照(Ambient Lighting)：即使在黑暗的情况下，世界上通常也仍然有一些光亮（月亮、远处的光），所以物体几乎永远不会是完全黑暗的。为了模拟这个，我们会使用一个环境光照常量，它永远会给物体一些颜色。
+ 漫反射光照(Diffuse Lighting)：模拟光源对物体的方向性影响(Directional Impact)。它是冯氏光照模型中视觉上最显著的分量。物体的某一部分越是正对着光源，它就会越亮。
+ 镜面光照(Specular Lighting)：模拟有光泽物体上面出现的亮点。镜面光照的颜色相比于物体的颜色会更倾向于光的颜色。

<h2>环境光照</h2>
光能够在其它的表面上反射，对一个物体产生间接的影响。考虑到这种情况的算法叫做全局照明(Global Illumination)算法，开销很大<br>
环境光照：使用一个很小的常量（光照）颜色，添加到物体片段的最终颜色中，这样子的话即便场景中没有直接的光源也能看起来存在有一些发散的光。（在片元着色器中修改）

<h2>漫反射光照</h2>
我们需要测量这个光线是以什么角度接触到这个片段的。如果光线垂直于物体表面，这束光对物体的影响会最大化<br>
通过点乘返回一个标量，我们可以用它计算光线对片段颜色的影响。不同片段朝向光源的方向的不同，这些片段被照亮的情况也不同。<br>
所以，计算漫反射光照需要:

+ 法向量：一个垂直于顶点表面的向量。
+ 定向的光线：作为光源的位置与片段的位置之间向量差的方向向量。为了计算这个光线，我们需要光的位置向量和片段的位置向量。

	<h3>法向量计算</h3>
	法向量是一个垂直于顶点表面的（单位）向量。由于顶点本身并没有表面（它只是空间中一个独立的点），我们利用它周围的顶点来计算出这个顶点的表面。<br>
	是不是应该把法向量也转换为世界空间坐标？基本正确，但是这不是简单地把它乘以一个模型矩阵就能搞定的:
	
	+ 法向量只是一个方向向量，不能表达空间中的特定位置。同时，法向量没有齐次坐标（顶点位置中的w分量）。这意味着，位移不应该影响到法向量。因此，如果我们打算把法向量乘以一个模型矩阵，我们就要从矩阵中移除位移部分，只选用模型矩阵左上角3×3的矩阵（注意，我们也可以把法向量的w分量设置为0，再乘以4×4矩阵；这同样可以移除位移）。对于法向量，我们只希望对它实施缩放和旋转变换。
	+ 如果模型矩阵执行了不等比缩放，顶点的改变会导致法向量不再垂直于表面

	修复这个行为的诀窍是使用一个为法向量专门定制的模型矩阵。这个矩阵称之为法线矩阵(Normal Matrix)（参考：http://www.lighthouse3d.com/tutorials/glsl-12-tutorial/the-normal-matrix/ ）
	
	简单记忆为：法线矩阵被定义为<b>「模型矩阵左上角的逆矩阵的转置矩阵」</b>
	
	`
	Normal = mat3(transpose(inverse(model))) * aNormal;
	`

<h2>镜面光照</h2>
镜面光照是基于光的反射特性，通过反射法向量周围光的方向来计算反射向量。然后我们计算反射向量和视线方向的角度差，如果夹角越小，那么镜面光的影响就会越大。它的作用效果就是，当我们去看光被物体所反射的那个方向的时候，我们会看到一个高光。

计算方法：观察向量是镜面光照附加的一个变量，我们可以使用观察者世界空间位置和片段的位置来计算它。之后，我们计算镜面光强度，用它乘以光源的颜色，再将它加上环境光和漫反射分量。

我们先计算视线方向与反射方向的点乘（并确保它不是负值），然后取它的32次幂。这个32是高光的反光度(Shininess)。一个物体的反光度越高，反射光的能力越强，散射得越少，高光点就会越小。

<h2>Gouraud Shading与Phong Shading</h2>
基于Exercise 4的分析

Gourand:逐顶点光照

![image](https://github.com/yu-cao/OpenGL-Learning/blob/master/2.2Basic%20Lighting/Reference/Gouraud.png)

Phong:逐像素光照

![image](https://github.com/yu-cao/OpenGL-Learning/blob/master/2.2Basic%20Lighting/Reference/Phong.png)

逐顶点Shading可以看到两个三角形之间比较明显的一个分割线，这是因为插值引起的。因为可以看到右下方的三角面靠近光源的顶点被镜面高光点亮，而余下的两个顶点没有被点亮，所以进行了插值。同理，左上角的三角形也是靠近光源的一个顶点被点亮，余下两个进行插值得到。而中间的一段因为这是两个插值得到的，而不是从光源直接计算出来的，所以两个三角形插值出现了碰撞导致了一个可见的条纹。